#include "config.h"
#include "modbus.h"
#include "stdio.h"

#if MB_SLAVE_ID
#warning	"Compile with Modbus Slave"
#else
#warning	"Compile with Modbus Master"

// 主机请求超时次数
u16 mb_master_timeout_count = 0;
// 主机状态
u8	mb_master_status = 0;

#endif // MB_SLAVE_ID

mb_receiver_t mb_receiver;
static u8 sendbuf[MB_BUF_MAXLENGTH] = {0};
static const u8 aucCRCHi[] = {
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40
};

static const u8 aucCRCLo[] = {
	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
	0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
	0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
	0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
	0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
	0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
	0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
	0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
	0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
	0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
	0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
	0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
	0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
	0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
	0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
	0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
	0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
	0x41, 0x81, 0x80, 0x40
};

u16 mb_calcu_crc(const u8 *dats, u16 len)
{
	u8	ucCRCHi = 0xFF;
	u8	ucCRCLo = 0xFF;
	int iIndex;

	while(len--)
	{
		iIndex = ucCRCLo ^ *( dats++ );
		ucCRCLo = ( u8 )( ucCRCHi ^ aucCRCHi[iIndex] );
		ucCRCHi = aucCRCLo[iIndex];
	}
	return ( u16 )( ucCRCHi << 8 | ucCRCLo );
}

void mb_init(void)
{
	mb_reset_receiver(&mb_receiver);
#if !MB_SLAVE_ID
	mb_master_status = MB_MASTER_STATUS_NONE;
#endif
}

void mb_reset_receiver(mb_receiver_t *recv)
{
	recv->status = MB_RECEIVER_STATUS_NONE;
	recv->datapos = 0;
}

void mb_receive_byte(mb_receiver_t *recv, u8 dat)
{
	if(recv->status == MB_RECEIVER_STATUS_NONE || recv->status == MB_RECEIVER_STATUS_RECEIVING){
		recv->status = MB_RECEIVER_STATUS_RECEIVING;
		recv->databuf[recv->datapos ++] = dat;
	}
}

void mb_send_bytes(const u8 *dats, u16 len)
{
	while(len--){
		mb_send_byte(*dats);
		++dats;
	}
}

void mb_send_frame(u8 *dats, u16 len)
{
	u16 crc = mb_calcu_crc(dats, len);
	dats[len] = (u8)(crc&0x00ff);
	dats[len+1] = (u8)(crc>>8);
	mb_send_bytes(sendbuf, len+2);
}


#if MB_SLAVE_ID
// 处理主机数据帧
void mb_event_handle_master_frame(u8 *frame, u16 len)
{
  u16 rlen = 0;
	u8 rcode = 0;
  sendbuf[0] = frame[0];
  sendbuf[1] = frame[1];

	// 根据功能码进行分发
	switch(frame[1])
	{
		case MB_FUNC_READREGISTERS:{
			u16 cnt = HLBYTE2U16(frame, 4);
			rcode = mb_event_read_registers(sendbuf+3, HLBYTE2U16(frame, 2), cnt);
			if(!rcode){
				// 字节数
				sendbuf[2] = (u8)(cnt*2);
				rlen = 3+cnt*2;
			}
			break;
		}
		case MB_FUNC_WRITEREGISTER:{
			rcode = mb_event_write_register(HLBYTE2U16(frame, 2), HLBYTE2U16(frame, 4));
			if(!rcode){
				sendbuf[2] = frame[2];
				sendbuf[3] = frame[3];
				sendbuf[4] = frame[4];
				sendbuf[5] = frame[5];
				rlen = 6;
			}
			break;
		}
		case MB_FUNC_WRITEREGISTERS:{
			rcode = mb_event_write_registers(frame+7, HLBYTE2U16(frame, 2), HLBYTE2U16(frame, 4));
			if(!rcode){
				sendbuf[2] = frame[2];
				sendbuf[3] = frame[3];
				sendbuf[4] = frame[4];
				sendbuf[5] = frame[5];
				rlen = 6;
			}
			break;
		}
		default:{
			rcode = 1;
			log_error("Unimplemented modbus function code: %d\n", (int)frame[1]);
			break;
		}
	}

	if(rcode){
		// 响应错误
		rlen = 3;
		sendbuf[1] = frame[1] | 0x80;
		sendbuf[2] = rcode;
	}

  if(rlen){
    mb_send_frame(sendbuf, rlen);
  }
}

#else

// 处理从机数据帧
void mb_event_handle_slave_frame(u8 *frame, u16 len)
{
	if(frame[1] & 0x80){
		// 返回错误
		mb_response_error(frame[0], frame[1], frame[2]);
	}
	else{
    switch(frame[1]){
		case MB_FUNC_READREGISTERS:{
			mb_response_read_registers(frame[0], frame[2], frame+3);
			break;
		}
		case MB_FUNC_WRITEREGISTER:{
			mb_response_write_register(frame[0], HLBYTE2U16(frame, 2), HLBYTE2U16(frame, 4));
			break;
		}
		case MB_FUNC_WRITEREGISTERS:{
			mb_response_write_registers(frame[0], HLBYTE2U16(frame, 2), HLBYTE2U16(frame, 4));
			break;
		}
		default:{
			log_error("Unimplemented modbus function code: %d\n", (int)frame[1]);
		}
		}
	}
}

void mb_write_register(u8 address, u16 reg_addr, u16 value)
{
	sendbuf[0] = address;
	sendbuf[1] = 0x06;
	U162HLBYTE(sendbuf, 2, reg_addr);
	U162HLBYTE(sendbuf, 4, value);
	mb_send_frame(sendbuf, 6);
}

void mb_read_registers(u8 address, u16 reg_start, u16 reg_count)
{
	sendbuf[0] = address;
	sendbuf[1] = 0x03;
	U162HLBYTE(sendbuf, 2, reg_start);
	U162HLBYTE(sendbuf, 4, reg_count);
	mb_send_frame(sendbuf, 6);
}

void mb_write_registers(u8 address, u16 reg_start, u16 reg_count, u16 *values)
{
  int i;
	sendbuf[0] = address;
	sendbuf[1] = 0x10;
	U162HLBYTE(sendbuf, 2, reg_start);
	U162HLBYTE(sendbuf, 4, reg_count);
	sendbuf[6] = reg_count*2;
	for(i=0; i<reg_count; ++i){
    U162HLBYTE(sendbuf, (7+i*2), values[i]);
	}
	mb_send_frame(sendbuf, 7+i*2);
}


#endif // MB_SLAVE_ID

void mb_event_handleframe(u8 *frame, u16 len)
{
#if MB_SLAVE_ID
	// 从机，处理主机数据帧
	mb_event_handle_master_frame(frame, len);
#else
	// 主机，处理从机数据帧
	mb_event_handle_slave_frame(frame, len);
#endif
}

u16 mb_event_timeout(mb_receiver_t *recv)
{
  u16 flag = 0;
	if(recv->datapos>4){
		u16 i;
		u16 crc, mb_crc;
		u16 len = recv->datapos-2;
		recv->status = MB_RECEIVER_STATUS_RECEIVED;

		crc = mb_calcu_crc(recv->databuf, len);

		log_debug("MODBUS ADD:0x%02x FUN:0x%02x FRAME-LEN:%d\n", recv->databuf[0], recv->databuf[1], recv->datapos);
		// CRC16校验
		mb_crc = LHBYTE2U16(recv->databuf,len);
		if(crc == mb_crc){
			// 校验正确
#if MB_SLAVE_ID
			// 从机
			if(recv->databuf[0] == 0 || recv->databuf[0]==MB_SLAVE_ID){
				// 是否是广播地址或者是自己的从机地址
				mb_event_handleframe(recv->databuf, len);
			}
			else{
				log_debug("addr not matching, ignore");
			}
#else
			// 主机
			mb_event_handleframe(recv->databuf, len);
#endif // MB_SLAVE_ID
		}
		else{
			log_error("CRC16 failed. %04x!=%04x\n data", crc, mb_crc);
			for(i=0; i<recv->datapos; ++i){
				printf("%02x ", recv->databuf[i]);
			}
			printf(" crc=%04x", crc);
			printf("\n");
		}
		#if !MB_SLAVE_ID

		#endif

		flag = 1;
	}
	mb_reset_receiver(recv);
	return flag;
}


